<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kanvas Desktop OS</title>
    <!-- Load Tailwind CSS for modern styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom font for system UI */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0d1117;
            color: #ffffff;
            height: 100vh;
            overflow: hidden; /* Prevent body scroll */
        }
        #desktop {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: calc(100vh - 48px); /* Height minus taskbar */
            /* Rebranded background */
            background: #1f2937 url('https://placehold.co/1920x1080/1f2937/8b5cf6?text=Kanvas+Desktop') center center / cover;
        }
        .window {
            position: absolute;
            min-width: 250px;
            min-height: 150px;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.4);
            border: 1px solid #374151;
            resize: both; /* Allow window resizing */
        }
        .window-header {
            cursor: grab;
        }
        .app-icon {
            cursor: pointer;
            transition: transform 0.1s;
        }
        .app-icon:hover {
            transform: scale(1.05);
        }
        .terminal-text { color: #38a169; }
        .error-text { color: #f56565; }
        .prompt { color: #90cdf4; }
        /* Custom scrollbar for the console output */
        .console-output::-webkit-scrollbar { width: 8px; }
        .console-output::-webkit-scrollbar-thumb { background-color: #4b5563; border-radius: 4px; }
        .console-output::-webkit-scrollbar-track { background-color: #1f2937; }
        .file-icon {
            cursor: pointer;
            transition: background 0.1s;
        }
        .file-icon:hover {
            background-color: #374151;
        }
        /* Style for the embedded browser */
        .browser-iframe {
            width: 100%;
            height: 100%;
            border: none;
        }
    </style>
</head>
<body>

    <!-- 1. The Desktop Area -->
    <div id="desktop">
        <!-- Desktop Icons for launching apps -->
        <div class="p-4 space-y-4">
            <div id="icon-explorer" class="app-icon w-20 text-center p-2 rounded-lg bg-black/30 hover:bg-black/50">
                <!-- Lucide folder icon -->
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="mx-auto text-yellow-400"><path d="M4 20h16a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-7.93a2 2 0 0 1-1.66-.9l-.82-1.2A2 2 0 0 0 7.93 3H4a2 2 0 0 0-2 2v13c0 1.1.9 2 2 2Z"></path></svg>
                <p class="text-xs mt-1">File Explorer</p>
            </div>
            <div id="icon-editor" class="app-icon w-20 text-center p-2 rounded-lg bg-black/30 hover:bg-black/50">
                <!-- Lucide file-text icon -->
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="mx-auto text-blue-400"><path d="M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z"></path><path d="M14 2v4a2 2 0 0 0 2 2h4"></path><path d="M10 9H8"></path><path d="M16 13H8"></path><path d="M16 17H8"></path></svg>
                <p class="text-xs mt-1">Text Editor</p>
            </div>
            <div id="icon-browser" class="app-icon w-20 text-center p-2 rounded-lg bg-black/30 hover:bg-black/50">
                <!-- Lucide globe icon -->
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="mx-auto text-red-400"><circle cx="12" cy="12" r="10"></circle><path d="M12 2a14.5 14.5 0 0 0 0 20M2 12h20"></path></svg>
                <p class="text-xs mt-1">Web Browser</p>
            </div>
            <div id="icon-terminal" class="app-icon w-20 text-center p-2 rounded-lg bg-black/30 hover:bg-black/50">
                <!-- Lucide terminal icon -->
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="mx-auto text-green-400"><polyline points="4 17 10 11 4 5"></polyline><line x1="12" x2="20" y1="17" y2="17"></line></svg>
                <p class="text-xs mt-1">Terminal</p>
            </div>
        </div>
        <!-- Windows will be dynamically inserted here -->
    </div>

    <!-- 2. The Taskbar -->
    <div id="taskbar" class="fixed bottom-0 left-0 right-0 h-12 bg-gray-800 border-t border-gray-700 flex justify-between items-center px-4 z-50">
        <div id="taskbar-apps" class="flex space-x-2">
            <!-- Running apps tabs will be inserted here -->
        </div>
        <div class="flex items-center space-x-4 text-xs">
            <div id="taskbar-status" class="space-x-2 text-gray-400">
                <span id="system-clock">Clock: 0</span>
                <span id="ram-usage">RAM: 0/256 KB</span>
                <span id="cpu-status" class="text-green-400">Idle</span>
            </div>
            <!-- Rebranded OS name -->
            <div class="text-white font-semibold">Kanvas OS</div>
        </div>
    </div>

    <!-- JavaScript for the Kanvas OS Simulator -->
    <script>
        // ======================================================================================
        //
        // CORE OS SIMULATION MODULES (Rebranded and Updated for FS and Browser)
        //
        // ======================================================================================

        /**
         * --------------------------------------------------------------------------------------
         * SECTION 1: SYSTEM CONSTANTS AND UTILITIES
         * --------------------------------------------------------------------------------------
         */

        const KB = 1024;
        const RAM_SIZE_KB = 256;
        const MAX_PROCESSES = 16;
        const TIME_QUANTUM = 3;
        const PROCESS_CYCLE_COST = 10;
        const INIT_PROCESS_ID = 0;

        const ProcessState = {
            NEW: 'NEW', READY: 'READY', RUNNING: 'RUNNING', WAITING: 'WAITING', TERMINATED: 'TERMINATED'
        };

        const SystemCallType = {
            CREATE_PROCESS: 'SYS_CREATE_PROC', TERMINATE_PROCESS: 'SYS_TERMINATE_PROC',
            ALLOCATE_MEMORY: 'SYS_ALLOC_MEM', FREE_MEMORY: 'SYS_FREE_MEM',
            FILE_WRITE: 'SYS_FILE_WRITE', FILE_READ: 'SYS_FILE_READ', IDLE: 'SYS_IDLE'
        };

        // Utility function for DOM interaction
        const $ = (id) => document.getElementById(id);
        const log = (message, type = 'terminal') => {
            const output = $('console-output');
            if (!output) return;

            const p = document.createElement('p');
            let classes = "text-gray-300";
            if (type === 'terminal') classes = "terminal-text";
            if (type === 'error') classes = "error-text";
            if (type === 'info') classes = "text-yellow-400";
            if (type === 'prompt') classes = "prompt";
            p.className = `text-sm ${classes}`;
            p.innerHTML = message;
            output.appendChild(p);
            output.scrollTop = output.scrollHeight;
        };

        // UUID Generator for window/app IDs
        const generateUUID = () => crypto.randomUUID();

        /**
         * --------------------------------------------------------------------------------------
         * SECTION 2: PROCESS CONTROL BLOCK (PCB) & KERNEL MODULES
         * --------------------------------------------------------------------------------------
         */

        class PCB {
            constructor(pid, requiredCycles, memorySize, name = `Task-${pid}`) {
                this.pid = pid;
                this.name = name;
                this.state = ProcessState.NEW;
                this.requiredCycles = requiredCycles;
                this.executedCycles = 0;
                this.priority = 10;
                this.memorySize = memorySize;
                this.memoryBase = -1;
                this.registers = { A: 0, B: 0, PC: 0 };
                this.windowId = null;
                log(`[KANVAS] PCB created for PID ${this.pid} (${this.name}). Memory: ${memorySize}KB`, 'info');
            }

            execute() {
                if (this.executedCycles < this.requiredCycles) {
                    this.executedCycles++;
                    this.registers.PC++;
                    this.registers.A += 1;
                    return true;
                }
                return false;
            }

            isComplete() {
                return this.executedCycles >= this.requiredCycles;
            }
        }

        class MemoryManager {
            constructor(sizeKB) {
                this.sizeKB = sizeKB;
                this.allocatedBlocks = [];
                log(`[KANVAS] Memory Manager initialized. Total RAM: ${sizeKB} KB.`, 'info');
            }

            allocate(pid, sizeKB) {
                if (sizeKB <= 0) return -1;
                const totalUsed = this.allocatedBlocks.reduce((sum, block) => sum + block.size, 0);
                if (totalUsed + sizeKB > this.sizeKB) {
                    log(`[ERROR] PID ${pid}: Insufficient memory. Request: ${sizeKB}KB, Free: ${this.getFreeMemory()}KB`, 'error');
                    return -1;
                }

                let currentAddress = 0;
                this.allocatedBlocks.sort((a, b) => a.start - b.start);

                for (const block of this.allocatedBlocks) {
                    const gapSize = block.start - currentAddress;
                    if (gapSize >= sizeKB) {
                        const newBlock = { start: currentAddress, size: sizeKB, pid: pid };
                        this.allocatedBlocks.push(newBlock);
                        this.allocatedBlocks.sort((a, b) => a.start - b.start);
                        log(`[MEM] PID ${pid} allocated ${sizeKB}KB at address ${currentAddress}.`, 'info');
                        return currentAddress;
                    }
                    currentAddress = block.start + block.size;
                }

                if (this.sizeKB - currentAddress >= sizeKB) {
                    const newBlock = { start: currentAddress, size: sizeKB, pid: pid };
                    this.allocatedBlocks.push(newBlock);
                    this.allocatedBlocks.sort((a, b) => a.start - b.start);
                    log(`[MEM] PID ${pid} allocated ${sizeKB}KB at address ${currentAddress}.`, 'info');
                    return currentAddress;
                }

                log(`[ERROR] PID ${pid}: Memory fragmentation prevents allocation of ${sizeKB}KB.`, 'error');
                return -1;
            }

            free(pid) {
                const initialCount = this.allocatedBlocks.length;
                this.allocatedBlocks = this.allocatedBlocks.filter(block => block.pid !== pid);
                if (initialCount !== this.allocatedBlocks.length) {
                    log(`[MEM] PID ${pid}: Freed memory. Total blocks removed: ${initialCount - this.allocatedBlocks.length}.`, 'info');
                    return true;
                }
                return false;
            }

            getFreeMemory() {
                const totalUsed = this.allocatedBlocks.reduce((sum, block) => sum + block.size, 0);
                return this.sizeKB - totalUsed;
            }

            getUsage() {
                const totalUsed = this.allocatedBlocks.reduce((sum, block) => sum + block.size, 0);
                return `${totalUsed}/${this.sizeKB}`;
            }
        }

        class FileSystem {
            constructor() {
                // Root directory structure
                this.root = {
                    'home': {
                        'user': {
                            'notes.txt': { type: 'file', content: 'Use the text editor to create and save new files!', size: 60 },
                            'README.md': { type: 'file', content: '# Kanvas FS\n\nThis is a simple file system simulator. Try exploring the directories.', size: 80 }
                        },
                        'admin': {}
                    },
                    'bin': {
                        'sysinfo.sh': { type: 'file', content: 'Displays system information', size: 30 }
                    },
                    'web': {
                        'index.html': { type: 'file', content: '<h1>Welcome to Kanvas Web</h1><p>This is a mock webpage on the simulated network.</p>', size: 80 }
                    }
                };
                this.currentPath = ['home', 'user'];
                log(`[FS] File System initialized.`, 'info');
            }

            _resolvePath(pathParts) {
                let current = this.root;
                for (const part of pathParts) {
                    if (current[part] === undefined) return null;
                    current = current[part];
                }
                return current;
            }

            // Normalizes a path string or array into an array of directory parts
            _normalizePath(path) {
                let pathParts = (typeof path === 'string' ? path.split('/') : path).filter(p => p.length > 0);
                let current = [];

                if (!path.startsWith('/')) {
                    current = [...this.currentPath];
                }

                const finalPath = [];
                for (const part of current.concat(pathParts)) {
                    if (part === '..') {
                        if (finalPath.length > 0) finalPath.pop();
                    } else if (part !== '.') {
                        finalPath.push(part);
                    }
                }
                return finalPath;
            }

            listDirectory(path) {
                let targetPathParts = this._normalizePath(path);
                const targetDir = this._resolvePath(targetPathParts);
                if (!targetDir) return { success: false, message: 'Directory not found.' };
                if (targetDir.type === 'file') return { success: false, message: `${path} is a file.` };

                return { success: true, files: Object.keys(targetDir) };
            }

            changeDirectory(path) {
                const newPathParts = this._normalizePath(path);
                const targetDir = this._resolvePath(newPathParts);

                if (!targetDir) return { success: false, message: 'Directory not found.' };
                if (targetDir.type === 'file') return { success: false, message: `${path} is a file, not a directory.` };

                this.currentPath = newPathParts;
                return { success: true, message: `Current path: /${this.currentPath.join('/')}` };
            }

            readFile(fullPath) {
                const pathParts = this._normalizePath(fullPath);
                const file = this._resolvePath(pathParts);

                if (!file || file.type !== 'file') {
                    return { success: false, message: `File not found: /${pathParts.join('/')}` };
                }
                return { success: true, content: file.content, name: pathParts[pathParts.length - 1] };
            }

            // Updated to handle file creation/overwrite
            writeFile(fullPath, content) {
                const pathParts = this._normalizePath(fullPath);
                const filename = pathParts.pop();
                const dir = this._resolvePath(pathParts);

                if (!dir || dir.type === 'file') {
                    return { success: false, message: 'Cannot write in this location.' };
                }

                const size = content.length;
                dir[filename] = { type: 'file', content: content, size: size };
                log(`[FS] Wrote ${size} bytes to /${pathParts.join('/')}/${filename}`, 'info');
                return { success: true, message: `File '${filename}' written successfully.` };
            }

            // NEW: Create directory function
            createDirectory(fullPath) {
                const pathParts = this._normalizePath(fullPath);
                const dirname = pathParts.pop();
                const parentDir = this._resolvePath(pathParts);

                if (!parentDir || parentDir.type === 'file') {
                    return { success: false, message: 'Cannot create directory here. Parent is a file or path is invalid.' };
                }
                if (parentDir[dirname]) {
                    return { success: false, message: `Item '${dirname}' already exists.` };
                }

                parentDir[dirname] = {}; // Create an empty directory object
                log(`[FS] Created directory /${pathParts.join('/')}/${dirname}`, 'info');
                return { success: true, message: `Directory '${dirname}' created successfully.` };
            }

            getCurrentPathString() {
                return '/' + this.currentPath.join('/');
            }
        }

        class Scheduler {
            constructor(quantum) {
                this.readyQueue = [];
                this.quantum = quantum;
                this.currentProcess = null;
                this.quantumCounter = 0;
            }

            addToReadyQueue(pid) {
                if (!this.readyQueue.includes(pid)) {
                    this.readyQueue.push(pid);
                }
            }

            getNextProcess(processes) {
                if (this.currentProcess && this.currentProcess.state === ProcessState.RUNNING) {
                    this.quantumCounter++;
                    if (this.quantumCounter < this.quantum) {
                        return this.currentProcess;
                    }
                    this.currentProcess.state = ProcessState.READY;
                    this.addToReadyQueue(this.currentProcess.pid);
                    log(`[SCHEDULER] PID ${this.currentProcess.pid} preempted (quantum expired).`, 'info');
                    this.quantumCounter = 0;
                    this.currentProcess = null;
                }

                if (!this.currentProcess && this.readyQueue.length > 0) {
                    const nextPid = this.readyQueue.shift();
                    const nextProcess = processes.get(nextPid);

                    if (nextProcess) {
                        nextProcess.state = ProcessState.RUNNING;
                        this.currentProcess = nextProcess;
                        this.quantumCounter = 1;
                        return this.currentProcess;
                    }
                }
                return null;
            }

            clearProcess(pid) {
                this.readyQueue = this.readyQueue.filter(id => id !== pid);
                if (this.currentProcess && this.currentProcess.pid === pid) {
                    this.currentProcess = null;
                }
            }
        }

        /**
         * --------------------------------------------------------------------------------------
         * SECTION 3: WINDOW MANAGER & GUI APPLICATIONS
         * --------------------------------------------------------------------------------------
         */

        class WindowManager {
            constructor(desktopElementId, kernel) {
                this.desktop = $(desktopElementId);
                this.kernel = kernel;
                this.windows = new Map();
                this.zIndexCounter = 1000;
                this.taskbar = $('taskbar-apps');
            }

            focusWindow(windowId) {
                const windowEntry = this.windows.get(windowId);
                if (windowEntry) {
                    this.zIndexCounter++;
                    windowEntry.element.style.zIndex = this.zIndexCounter;
                    Array.from(this.taskbar.children).forEach(btn => {
                        if (btn.dataset.windowId === windowId) {
                            btn.classList.add('bg-indigo-600');
                            btn.classList.remove('bg-gray-700');
                        } else {
                            btn.classList.remove('bg-indigo-600');
                            btn.classList.add('bg-gray-700');
                        }
                    });
                }
            }

            launchApp(appName, AppClass, width = 600, height = 400) {
                const processName = `${appName}-${this.kernel.pidCounter + 1}`;
                const memorySize = 32;
                const requiredCycles = 50 + Math.floor(Math.random() * 50);
                this.kernel.createProcess(processName, memorySize, requiredCycles);
                const pcb = this.kernel.processes.get(this.kernel.pidCounter);
                const windowId = generateUUID();

                const windowElement = document.createElement('div');
                windowElement.id = `win-${windowId}`;
                windowElement.className = 'window bg-gray-900 border-gray-700 flex flex-col';
                windowElement.style.width = `${width}px`;
                windowElement.style.height = `${height}px`;
                windowElement.style.top = `${50 + this.windows.size * 20}px`;
                windowElement.style.left = `${50 + this.windows.size * 20}px`;
                windowElement.dataset.windowId = windowId;

                windowElement.innerHTML = `
                    <div class="window-header flex justify-between items-center p-2 bg-gray-800 text-sm font-semibold text-white border-b border-gray-700 select-none">
                        <span>${appName} [PID ${pcb.pid}]</span>
                        <div class="flex space-x-1">
                            <button data-action="minimize" class="w-5 h-5 flex items-center justify-center text-xs rounded hover:bg-gray-600">-</button>
                            <button data-action="close" class="w-5 h-5 flex items-center justify-center text-xs rounded hover:bg-red-700">X</button>
                        </div>
                    </div>
                    <div id="content-${windowId}" class="flex-grow p-2 overflow-auto bg-gray-900">
                        <!-- App Content Goes Here -->
                    </div>
                `;

                this.desktop.appendChild(windowElement);

                const appInstance = new AppClass(windowId, pcb, this.kernel);
                appInstance.renderContent($(`content-${windowId}`));

                this.windows.set(windowId, { element: windowElement, pcb, appInstance });
                pcb.windowId = windowId;

                this._makeDraggable(windowElement);
                windowElement.addEventListener('mousedown', () => this.focusWindow(windowId));

                this._addTaskbarButton(windowId, appName, pcb.pid);
                this.focusWindow(windowId);

                windowElement.querySelector('[data-action="close"]').addEventListener('click', () => {
                    this.closeApp(windowId);
                });
                windowElement.querySelector('[data-action="minimize"]').addEventListener('click', () => {
                    this.toggleMinimize(windowId);
                });

                log(`[WM] Launched ${appName} (PID ${pcb.pid}, Window ${windowId})`, 'info');
            }

            closeApp(windowId) {
                const entry = this.windows.get(windowId);
                if (entry) {
                    this.kernel.handleSystemCall(SystemCallType.TERMINATE_PROCESS, entry.pcb.pid);

                    entry.element.remove();
                    this.windows.delete(windowId);

                    $(`task-${windowId}`)?.remove();

                    log(`[WM] Closed window for PID ${entry.pcb.pid}`, 'info');
                }
            }

            toggleMinimize(windowId) {
                const entry = this.windows.get(windowId);
                if (entry) {
                    const isHidden = entry.element.style.display === 'none';
                    entry.element.style.display = isHidden ? 'flex' : 'none';
                    if (isHidden) {
                        this.focusWindow(windowId);
                    } else {
                        $(`task-${windowId}`).classList.remove('bg-indigo-600');
                        $(`task-${windowId}`).classList.add('bg-gray-700');
                    }
                }
            }

            // FIX: Added null check for header element
            _makeDraggable(element) {
                const header = element.querySelector('.window-header');

                if (!header) {
                    // console.error("Window header not found for dragging on element:", element.id);
                    return;
                }

                let isDragging = false;
                let offsetX, offsetY;

                header.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    this.focusWindow(element.dataset.windowId);
                    offsetX = e.clientX - element.getBoundingClientRect().left;
                    offsetY = e.clientY - element.getBoundingClientRect().top;
                    header.style.cursor = 'grabbing';
                });

                document.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;
                    e.preventDefault();
                    let newX = e.clientX - offsetX;
                    let newY = e.clientY - offsetY;

                    const desktopRect = this.desktop.getBoundingClientRect();
                    newX = Math.max(0, Math.min(newX, desktopRect.width - element.offsetWidth));
                    newY = Math.max(0, Math.min(newY, desktopRect.height - element.offsetHeight));

                    element.style.left = `${newX}px`;
                    element.style.top = `${newY}px`;
                });

                document.addEventListener('mouseup', () => {
                    isDragging = false;
                    header.style.cursor = 'grab';
                });
            }

            _addTaskbarButton(windowId, appName, pid) {
                const button = document.createElement('button');
                button.id = `task-${windowId}`;
                button.dataset.windowId = windowId;
                button.className = 'px-3 py-1 text-xs rounded transition-colors bg-gray-700 hover:bg-indigo-500 text-white';
                button.textContent = `${appName} (PID ${pid})`;
                button.addEventListener('click', () => {
                    const entry = this.windows.get(windowId);
                    if (entry.element.style.display === 'none') {
                        this.toggleMinimize(windowId);
                    }
                    this.focusWindow(windowId);
                });
                this.taskbar.appendChild(button);
            }
        }

        // --- Base Application Class ---
        class BaseApp {
            constructor(windowId, pcb, kernel) {
                this.windowId = windowId;
                this.pcb = pcb;
                this.kernel = kernel;
            }

            // This method must be overridden by child classes
            renderContent(container) {
                container.innerHTML = `<p class="p-4">App content goes here...</p>`;
            }
        }

        // --- 3.1: File Explorer Application (GUI) ---
        class FileExplorerApp extends BaseApp {
            constructor(windowId, pcb, kernel) {
                super(windowId, pcb, kernel);
                this.currentPath = this.kernel.fileSystem.getCurrentPathString();
            }

            renderContent(container) {
                container.className = 'flex flex-col flex-grow bg-gray-800 text-white p-2 space-y-2';
                container.innerHTML = `
                    <div class="flex flex-col space-y-2">
                        <div class="flex space-x-2 p-1 bg-gray-700 rounded-lg items-center">
                            <span class="text-xs font-mono text-indigo-300">Path:</span>
                            <input id="path-${this.windowId}" type="text" class="flex-grow bg-gray-900 border border-gray-600 rounded px-2 py-1 text-sm focus:outline-none" value="${this.currentPath}" readonly/>
                            <button id="up-btn-${this.windowId}" class="p-1 rounded bg-gray-600 hover:bg-gray-500 text-xs">Up</button>
                        </div>
                        <div class="flex space-x-2">
                            <input id="new-item-name-${this.windowId}" type="text" class="flex-grow bg-gray-900 border border-gray-600 rounded px-2 py-1 text-sm focus:outline-none" placeholder="New file or folder name"/>
                            <button id="new-file-btn-${this.windowId}" class="px-3 py-1 rounded bg-green-600 hover:bg-green-500 text-xs font-semibold">New File</button>
                            <button id="new-dir-btn-${this.windowId}" class="px-3 py-1 rounded bg-yellow-600 hover:bg-yellow-500 text-xs font-semibold">New Folder</button>
                        </div>
                    </div>
                    <div id="file-list-${this.windowId}" class="flex-grow overflow-y-auto space-y-1 p-2 border border-gray-700 rounded bg-gray-900 text-sm">
                        <!-- File/Folder list goes here -->
                    </div>
                `;

                this.updateFileList();

                // Event Listeners
                $(`up-btn-${this.windowId}`).addEventListener('click', () => this.navigate('..'));
                $(`new-file-btn-${this.windowId}`).addEventListener('click', () => this.createNewItem('file'));
                $(`new-dir-btn-${this.windowId}`).addEventListener('click', () => this.createNewItem('dir'));
            }

            // NEW: Creation logic
            createNewItem(type) {
                const nameInput = $(`new-item-name-${this.windowId}`);
                const name = nameInput.value.trim();

                if (!name) {
                    return log(`[FS] Please enter a name for the new ${type}.`, 'error');
                }

                const fullPath = this.currentPath + (this.currentPath.endsWith('/') ? '' : '/') + name;
                let result;

                if (type === 'dir') {
                    result = this.kernel.fileSystem.createDirectory(fullPath);
                } else {
                    // For a new file, create it with empty content
                    result = this.kernel.fileSystem.writeFile(fullPath, 'Type content here...');
                }

                if (result.success) {
                    nameInput.value = ''; // Clear input
                    this.updateFileList();
                } else {
                    log(`[FS] Failed to create ${type}: ${result.message}`, 'error');
                }
            }

            updateFileList() {
                const listContainer = $(`file-list-${this.windowId}`);
                const pathInput = $(`path-${this.windowId}`);
                listContainer.innerHTML = '';

                const result = this.kernel.fileSystem.listDirectory(this.currentPath);

                if (!result.success) {
                    listContainer.innerHTML = `<p class="error-text">Error: ${result.message}</p>`;
                    return;
                }

                if (this.currentPath !== '/') {
                    listContainer.appendChild(this._createFileItem('..', 'folder'));
                }

                const sortedFiles = result.files.sort((a, b) => {
                    const pathA = this.kernel.fileSystem._normalizePath(this.currentPath + '/' + a);
                    const pathB = this.kernel.fileSystem._normalizePath(this.currentPath + '/' + b);

                    const isAFolder = !this.kernel.fileSystem._resolvePath(pathA)?.type;
                    const isBFolder = !this.kernel.fileSystem._resolvePath(pathB)?.type;

                    if (isAFolder && !isBFolder) return -1;
                    if (!isAFolder && isBFolder) return 1;
                    return a.localeCompare(b);
                });

                sortedFiles.forEach(name => {
                    const fullPath = this.kernel.fileSystem._normalizePath(this.currentPath + '/' + name);
                    const item = this.kernel.fileSystem._resolvePath(fullPath);

                    if (item) {
                        const type = item.type === 'file' ? 'file' : 'folder';
                        listContainer.appendChild(this._createFileItem(name, type, fullPath.join('/')));
                    }
                });

                pathInput.value = this.currentPath;
            }

            _createFileItem(name, type, fullPath = null) {
                const itemDiv = document.createElement('div');
                const icon = type === 'folder'
                    ? `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-yellow-400"><path d="M4 20h16a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-7.93a2 2 0 0 1-1.66-.9l-.82-1.2A2 2 0 0 0 7.93 3H4a2 2 0 0 0-2 2v13c0 1.1.9 2 2 2Z"></path></svg>`
                    : `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-blue-400"><path d="M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z"></path><path d="M14 2v4a2 2 0 0 0 2 2h4"></path></svg>`;

                itemDiv.className = 'file-icon flex items-center space-x-2 p-1 rounded';
                itemDiv.innerHTML = `${icon}<span>${name}</span>`;

                itemDiv.addEventListener('dblclick', () => {
                    if (type === 'folder') {
                        this.navigate(name);
                    } else if (type === 'file') {
                        // Open file in Text Editor
                        const fullPathStr = fullPath ? '/' + fullPath : this.currentPath + '/' + name;
                        desktopManager.windowManager.launchApp('Text Editor', TextEditorApp, 700, 500);
                        const newApp = desktopManager.windowManager.windows.get(this.kernel.pidCounter.toString()).appInstance;
                        newApp.loadFile(fullPathStr);
                    }
                });

                return itemDiv;
            }

            navigate(name) {
                let newPath;
                if (name === '..') {
                    const parts = this.kernel.fileSystem._normalizePath(this.currentPath);
                    parts.pop();
                    newPath = '/' + parts.join('/');
                    if (newPath === '') newPath = '/';
                } else {
                    newPath = this.currentPath + (this.currentPath.endsWith('/') ? '' : '/') + name;
                }

                const normalizedPath = this.kernel.fileSystem._normalizePath(newPath);
                const targetDir = this.kernel.fileSystem._resolvePath(normalizedPath);

                if (targetDir && targetDir.type !== 'file') {
                    this.currentPath = '/' + normalizedPath.join('/');
                    if (this.currentPath === '//') this.currentPath = '/';
                    this.updateFileList();
                } else {
                    log(`[FS] Cannot navigate to ${name}`, 'error');
                }
            }
        }

        // --- 3.2: Text Editor Application (Simulated) ---
        class TextEditorApp extends BaseApp {
            constructor(windowId, pcb, kernel) {
                super(windowId, pcb, kernel);
                this.content = "";
                this.fileName = "Untitled.txt";
                this.filePath = "";
            }

            renderContent(container) {
                container.className = 'flex flex-col flex-grow bg-gray-900 text-white p-1 space-y-2';
                container.innerHTML = `
                    <div class="flex space-x-2 p-1 bg-gray-800 rounded-lg items-center">
                        <span class="text-sm font-mono text-blue-300 mr-2" id="editor-title-${this.windowId}">${this.fileName}</span>
                        <button id="save-btn-${this.windowId}" class="px-3 py-1 rounded bg-indigo-600 hover:bg-indigo-500 text-white text-xs font-semibold">Save</button>
                    </div>
                    <textarea id="text-area-${this.windowId}" class="flex-grow w-full bg-black/50 border border-gray-700 rounded p-4 text-sm resize-none focus:outline-none focus:border-indigo-500" placeholder="Start typing..."></textarea>
                `;

                // Event Listeners
                $(`save-btn-${this.windowId}`).addEventListener('click', () => this.saveFile());
                $(`text-area-${this.windowId}`).value = this.content;
            }

            loadFile(fullPath) {
                const result = this.kernel.fileSystem.readFile(fullPath);
                if (result.success) {
                    this.content = result.content;
                    this.filePath = fullPath;
                    this.fileName = result.name;
                    $(`editor-title-${this.windowId}`).textContent = this.fileName;
                    $(`text-area-${this.windowId}`).value = this.content;
                    log(`[EDITOR] Loaded file ${this.fileName} from ${this.filePath}`, 'info');
                } else {
                    log(`[EDITOR] Error loading file: ${result.message}`, 'error');
                }
            }

            saveFile() {
                this.content = $(`text-area-${this.windowId}`).value;
                let path = this.filePath;

                if (!path) {
                    // For unsaved files, default to the user's home directory
                    path = this.kernel.fileSystem.getCurrentPathString() + '/' + this.fileName;
                }

                const result = this.kernel.fileSystem.writeFile(path, this.content);

                if (result.success) {
                    this.filePath = path;
                    $(`editor-title-${this.windowId}`).textContent = this.fileName + ' (Saved)';
                    log(`[EDITOR] File saved successfully to ${this.filePath}`, 'info');
                } else {
                    log(`[EDITOR] Save failed: ${result.message}`, 'error');
                }
            }
        }

        // --- 3.3: Web Browser Application (External Iframe) ---
        class BrowserApp extends BaseApp {
            constructor(windowId, pcb, kernel) {
                super(windowId, pcb, kernel);
                // CHANGED default URL to Wikipedia main page (embed-friendly example)
                this.defaultURL = 'https://en.wikipedia.org/wiki/Main_Page';
                this.currentURL = this.defaultURL;
            }

            renderContent(container) {
                container.className = 'flex flex-col flex-grow bg-gray-100 text-gray-900 p-0';
                container.innerHTML = `
                    <div class="flex p-2 bg-gray-200 border-b border-gray-300 space-x-2">
                        <input id="url-input-${this.windowId}" type="text" class="flex-grow bg-white border border-gray-400 rounded px-2 text-sm focus:outline-none" value="${this.currentURL}" placeholder="Enter URL (https:// required) or /local/path"/>
                        <button id="go-btn-${this.windowId}" class="px-3 py-1 rounded bg-blue-500 hover:bg-blue-600 text-white text-sm">Go</button>
                    </div>
                    <div id="browser-view-${this.windowId}" class="flex-grow overflow-hidden text-sm bg-white">
                        <iframe id="browser-iframe-${this.windowId}" class="browser-iframe" src="${this.defaultURL}"></iframe>
                    </div>
                    <div id="browser-warning-${this.windowId}" class="p-1 text-center bg-yellow-100 text-yellow-800 text-xs font-medium">
                        <span id="warning-text-${this.windowId}">Loading...</span>
                    </div>
                `;

                // Event Listeners
                $(`go-btn-${this.windowId}`).addEventListener('click', () => this.navigate($(`url-input-${this.windowId}`).value));
                $(`url-input-${this.windowId}`).addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') this.navigate($(`url-input-${this.windowId}`).value);
                });

                // UPDATED warning message
                this.updateWarning(true, "Note: Major search engines (Google, DuckDuckGo) block embedding. Try specific URLs or use /local/path to access Kanvas FS files.");
            }

            updateWarning(show, message = "") {
                const warningElement = $(`browser-warning-${this.windowId}`);
                const warningText = $(`warning-text-${this.windowId}`);
                if (show) {
                    warningText.textContent = message;
                    warningElement.style.display = 'block';
                } else {
                    warningElement.style.display = 'none';
                }
            }

            navigate(url) {
                url = url.trim();
                const iframe = $(`browser-iframe-${this.windowId}`);
                $(`url-input-${this.windowId}`).value = url;
                this.currentURL = url;

                this.updateWarning(false); // Clear warning initially

                // 1. Check for Local File System Path
                if (url.startsWith('/')) {
                    const result = this.kernel.fileSystem.readFile(url);
                    if (result.success) {
                        const htmlContent = `
                            <!DOCTYPE html>
                            <html lang="en">
                            <head>
                                <title>${result.name}</title>
                                <style>body { font-family: 'Inter', sans-serif; background-color: #fff; color: #333; padding: 20px; }</style>
                            </head>
                            <body>
                                ${result.content}
                            </body>
                            </html>
                        `;
                        // Load HTML directly into the iframe using a data URI
                        iframe.src = `data:text/html;charset=utf-8,${encodeURIComponent(htmlContent)}`;
                        this.updateWarning(true, `Loaded local file: ${result.name}`);
                    } else {
                        iframe.src = 'about:blank';
                        this.updateWarning(true, `Error: Local file not found at ${url}`);
                    }
                }
                // 2. Load External URL (Requires https:// and browser embedding capability)
                else if (url.startsWith('http')) {
                    if (!url.startsWith('https://')) {
                         // Force HTTPS for better compatibility
                        url = 'https://' + url.replace(/^(http|https):\/\//, '');
                    }
                    iframe.src = url;
                    this.updateWarning(true, "Attempting to load external website. If it fails, the site likely blocks embedding (X-Frame-Options/CSP).");
                }
                // 3. Default Search/Invalid URL (Try as an external URL, but warn)
                else {
                    const fullUrl = `https://${url}`;
                    iframe.src = fullUrl;
                    this.updateWarning(true, `Attempting to load external website. If it fails, the site likely blocks embedding (X-Frame-Options/CSP).`);
                }
            }
        }

        // --- 3.4: Terminal Console Application (Rebranded) ---
        class TerminalApp extends BaseApp {
            renderContent(container) {
                container.className = 'flex flex-col flex-grow bg-gray-900 overflow-hidden';
                container.innerHTML = `
                    <div id="console-output" class="console-output flex-grow p-4 text-sm overflow-y-auto space-y-1 bg-black/50">
                        <p class="text-yellow-400">Kanvas Terminal Ready. Type 'help' for commands.</p>
                    </div>
                    <div class="p-3 border-t border-gray-700 flex items-center bg-gray-800">
                        <span class="prompt text-sm mr-2">root@kanvas $</span>
                        <input type="text" id="console-input" class="flex-grow bg-transparent terminal-text focus:outline-none" autofocus placeholder="Type commands..." />
                    </div>
                `;

                this.inputElement = $('console-input');
                this.inputElement.addEventListener('keypress', this.handleInput.bind(this));
            }

            handleInput(event) {
                if (event.key === 'Enter') {
                    const commandLine = this.inputElement.value.trim();
                    log(`<span class="prompt">root@kanvas $</span> ${commandLine}`, 'prompt');
                    this.inputElement.value = '';

                    if (commandLine) {
                        this.executeCommand(commandLine);
                    }
                }
            }

            executeCommand(commandLine) {
                const parts = commandLine.toLowerCase().split(/\s+/);
                const command = parts[0];
                const args = parts.slice(1);

                if (!this.kernel.timer && command !== 'start') {
                    return log("[ERROR] Kernel is not running. Type 'start' to boot the OS.", 'error');
                }

                switch (command) {
                    case 'help': this.showHelp(); break;
                    case 'start': this.kernel.start(); break;
                    case 'stop': this.kernel.stop(); break;
                    case 'ps': this.showProcessList(); break;
                    case 'exec': this.execProcess(args); break;
                    case 'kill': this.killProcess(args); break;
                    case 'ls': this.listDir(args); break;
                    case 'cd': this.changeDir(args); break;
                    case 'cat': this.readCat(args); break;
                    case 'mkdir': this.makeDir(args); break; // NEW COMMAND
                    case 'echo': this.writeEcho(commandLine); break;
                    case 'clear': $('console-output').innerHTML = ''; break;
                    case 'reboot': log("Simulating reboot...", 'info'); this.kernel.stop(); setTimeout(() => this.kernel.start(), 1000); break;
                    default: log(`[ERROR] Command not found: ${command}.`, 'error');
                }
            }

            showHelp() {
                log("<br>--- Kanvas Terminal Commands ---", 'info');
                log("  <span class='text-yellow-400'>start | stop | reboot</span>: Control kernel state.");
                log("  <span class='text-yellow-400'>ps | exec [name] [mem] [cycles] | kill [pid]</span>: Process Management.");
                log("  <span class='text-yellow-400'>ls [path] | cd [path] | cat [file] | mkdir [dir] | echo [content] > [file]</span>: File System Ops.");
                log("  <span class='text-yellow-400'>clear</span>: Clear the console output.");
            }

            showProcessList() {
                log("<br>--- Active Processes (PID | Name | State | Cycles) ---", 'info');
                let found = false;
                this.kernel.processes.forEach(pcb => {
                    if (pcb.pid !== INIT_PROCESS_ID) {
                        log(`  ${pcb.pid} | ${pcb.name.padEnd(8)} | ${pcb.state.padEnd(10)} | ${pcb.executedCycles}/${pcb.requiredCycles}`);
                        found = true;
                    }
                });
                if (!found) log("  No user processes running.", 'info');
                log("<br>");
            }

            execProcess(args) {
                const name = args[0] || `Proc-${Math.floor(Math.random() * 100)}`;
                const mem = parseInt(args[1]) || 32;
                const cycles = parseInt(args[2]) || PROCESS_CYCLE_COST;
                if (mem < 8 || cycles < 1) return log("[ERROR] Invalid memory/cycle parameters. Min mem: 8KB, Min cycles: 1.", 'error');
                this.kernel.createProcess(name, mem, cycles);
            }

            killProcess(args) {
                const pid = parseInt(args[0]);
                if (isNaN(pid) || pid <= INIT_PROCESS_ID || !this.kernel.processes.has(pid)) {
                    return log("[ERROR] Invalid PID.", 'error');
                }
                this.kernel.handleSystemCall(SystemCallType.TERMINATE_PROCESS, pid);
            }

            listDir(args) {
                const path = args[0] || this.kernel.fileSystem.getCurrentPathString();
                const result = this.kernel.fileSystem.listDirectory(path);
                if (result.success) {
                    log(`Contents of ${path}:`, 'info');
                    result.files.forEach(name => log(`  ${name}`));
                } else {
                    log(`[ERROR] ${result.message}`, 'error');
                }
            }

            changeDir(args) {
                const path = args[0];
                if (!path) return log("[ERROR] Usage: cd <path>", 'error');
                const result = this.kernel.fileSystem.changeDirectory(path);
                if (result.success) {
                    log(result.message, 'info');
                } else {
                    log(`[ERROR] ${result.message}`, 'error');
                }
            }

            // NEW: mkdir command
            makeDir(args) {
                const dirname = args[0];
                if (!dirname) return log("[ERROR] Usage: mkdir <dirname>", 'error');

                // Resolve full path relative to current directory
                const fullPath = this.kernel.fileSystem.getCurrentPathString() + (this.kernel.fileSystem.getCurrentPathString().endsWith('/') ? '' : '/') + dirname;
                const result = this.kernel.fileSystem.createDirectory(fullPath);

                if (result.success) {
                    log(result.message, 'info');
                } else {
                    log(`[ERROR] ${result.message}`, 'error');
                }
            }

            readCat(args) {
                const filename = args[0];
                if (!filename) return log("[ERROR] Usage: cat <filename>", 'error');
                const result = this.kernel.fileSystem.readFile(filename);
                if (result.success) {
                    log(`--- Content of ${filename} ---`, 'info');
                    log(result.content);
                } else {
                    log(`[ERROR] ${result.message}`, 'error');
                }
            }

            writeEcho(commandLine) {
                const match = commandLine.match(/^echo\s+(.+?)\s+>\s+(.+)$/i);
                if (!match || match.length < 3) return log("[ERROR] Usage: echo <content> > <filename>", 'error');
                const content = match[1].trim();
                const filename = match[2].trim();
                const result = this.kernel.fileSystem.writeFile(filename, content);
                if (!result.success) {
                    log(`[ERROR] ${result.message}`, 'error');
                }
            }
        }

        /**
         * --------------------------------------------------------------------------------------
         * SECTION 4: THE OS KERNEL (MAIN INTEGRATOR)
         * --------------------------------------------------------------------------------------
         */

        class OS_Kernel {
            constructor() {
                this.clock = 0;
                this.pidCounter = INIT_PROCESS_ID;
                this.processes = new Map();
                this.memManager = new MemoryManager(RAM_SIZE_KB);
                this.scheduler = new Scheduler(TIME_QUANTUM);
                this.fileSystem = new FileSystem();

                this.timer = null;
                this.TICK_RATE_MS = 100;

                this.initIdleProcess();
            }

            setWindowManager(wm) {
                this.windowManager = wm;
            }

            initIdleProcess() {
                const idlePCB = new PCB(INIT_PROCESS_ID, Infinity, 0, 'Idle');
                idlePCB.state = ProcessState.RUNNING;
                this.processes.set(INIT_PROCESS_ID, idlePCB);
                this.scheduler.currentProcess = idlePCB;
                log(`[KANVAS] Initializing Kanvas Kernel... Idle Process (PID ${INIT_PROCESS_ID}) started.`, 'info');
            }

            start() {
                if (this.timer) return;
                log("[KANVAS] Simulation starting...", 'info');
                this.timer = setInterval(() => this.systemTick(), this.TICK_RATE_MS);
            }

            stop() {
                if (this.timer) {
                    clearInterval(this.timer);
                    this.timer = null;
                    log("[KANVAS] Simulation halted.", 'info');
                }
            }

            systemTick() {
                this.clock++;
                let currentProcess = this.scheduler.getNextProcess(this.processes);

                if (!currentProcess) {
                    currentProcess = this.processes.get(INIT_PROCESS_ID);
                }

                if (currentProcess) {
                    const isRunning = currentProcess.execute();
                    if (!isRunning) {
                        this.handleSystemCall(SystemCallType.TERMINATE_PROCESS, currentProcess.pid);
                    }
                }

                this.updateUI();
            }

            handleSystemCall(type, pid) {
                const pcb = this.processes.get(pid);
                if (!pcb) return console.error(`[ERROR] System Call failed: PID ${pid} not found.`);

                switch (type) {
                    case SystemCallType.TERMINATE_PROCESS:
                        pcb.state = ProcessState.TERMINATED;
                        this.scheduler.clearProcess(pid);
                        this.memManager.free(pid);

                        if (pcb.windowId && this.windowManager) {
                            const taskbarButton = $(`task-${pcb.windowId}`);
                            if (taskbarButton) taskbarButton.remove();

                            this.windowManager.windows.delete(pcb.windowId);
                            const windowElement = $(`win-${pcb.windowId}`);
                            if (windowElement) windowElement.remove();
                        }

                        this.processes.delete(pid);
                        log(`[KANVAS] PID ${pid} (${pcb.name}) terminated.`, 'info');
                        break;
                    default:
                        log(`[ERROR] Unknown system call type: ${type}`, 'error');
                }
            }

            createProcess(name, memorySizeKB = 32, requiredCycles = PROCESS_CYCLE_COST) {
                if (this.processes.size >= MAX_PROCESSES) {
                    return log(`[ERROR] Cannot create process: Max process limit (${MAX_PROCESSES}) reached.`, 'error');
                }

                const newPid = ++this.pidCounter;
                const baseAddress = this.memManager.allocate(newPid, memorySizeKB);

                if (baseAddress === -1) {
                    this.pidCounter--;
                    return;
                }

                const newPCB = new PCB(newPid, requiredCycles, memorySizeKB, name);
                newPCB.memoryBase = baseAddress;
                newPCB.state = ProcessState.READY;

                this.processes.set(newPid, newPCB);
                this.scheduler.addToReadyQueue(newPid);

                log(`[KANVAS] New process '${name}' created (PID ${newPid}). Added to Ready Queue.`, 'info');
                return newPid;
            }

            updateUI() {
                const currentProcess = this.scheduler.currentProcess;
                const isIdle = !currentProcess || currentProcess.pid === INIT_PROCESS_ID;
                const cpuStatusElement = $('cpu-status');

                $('system-clock').textContent = `Clock: ${this.clock}`;
                $('ram-usage').textContent = `RAM: ${this.memManager.getUsage()} KB`;

                if (isIdle) {
                    cpuStatusElement.textContent = 'Idle';
                    cpuStatusElement.className = 'text-green-400';
                } else {
                    cpuStatusElement.textContent = `Running PID ${currentProcess.pid}`;
                    cpuStatusElement.className = 'text-yellow-400';
                }
            }
        }

        /**
         * --------------------------------------------------------------------------------------
         * SECTION 5: DESKTOP MANAGER & INITIALIZATION
         * --------------------------------------------------------------------------------------
         */

        let kernel;
        let desktopManager;

        class DesktopManager {
            constructor() {
                this.kernel = new OS_Kernel();
                this.windowManager = new WindowManager('desktop', this.kernel);
                this.kernel.setWindowManager(this.windowManager);

                this.bindDesktopIcons();

                // Start the kernel automatically for a modern OS feel
                this.kernel.start();
            }

            bindDesktopIcons() {
                $('icon-explorer').addEventListener('dblclick', () => {
                    this.windowManager.launchApp('File Explorer', FileExplorerApp, 750, 550);
                });
                $('icon-editor').addEventListener('dblclick', () => {
                    this.windowManager.launchApp('Text Editor', TextEditorApp, 700, 500);
                });
                $('icon-browser').addEventListener('dblclick', () => {
                    this.windowManager.launchApp('Kanvas Web Browser', BrowserApp, 800, 600);
                });
                $('icon-terminal').addEventListener('dblclick', () => {
                    this.windowManager.launchApp('Terminal', TerminalApp, 650, 450);
                });
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            desktopManager = new DesktopManager();

            log("Kanvas Desktop OS v2.3 Initialized. Double-click icons to launch apps.", 'info');
        });

    </script>
</body>
</html>
